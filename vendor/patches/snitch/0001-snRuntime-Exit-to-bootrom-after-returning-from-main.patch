From 42766ad04a717d3f03c08e2ea17c325b693c0bd7 Mon Sep 17 00:00:00 2001
From: Cyril Koenig <cykoenig@iis.ee.ethz.ch>
Date: Mon, 16 Jan 2023 11:31:35 +0100
Subject: [PATCH 01/16] [snRuntime] Exit to bootrom after returning from main

---
 sw/snRuntime/link/common.ld.in                 |  2 ++
 sw/snRuntime/src/platforms/hero/start_snitch.S | 40 ++++++++++++++++++++++++++
 sw/snRuntime/src/start.S                       | 17 ++++++++++-
 3 files changed, 58 insertions(+), 1 deletion(-)
 create mode 100644 sw/snRuntime/src/platforms/hero/start_snitch.S

diff --git a/sw/snRuntime/link/common.ld.in b/sw/snRuntime/link/common.ld.in
index 41ec54d8..63423e10 100644
--- a/sw/snRuntime/link/common.ld.in
+++ b/sw/snRuntime/link/common.ld.in
@@ -12,6 +12,8 @@ MEMORY
 
 SECTIONS
 {
+  /* Make sure the init section is at the beginning of the binary */
+  .init : { *(.init) } >DRAM
   /* The program code and other data goes into DRAM */
   .text :
   {
diff --git a/sw/snRuntime/src/platforms/hero/start_snitch.S b/sw/snRuntime/src/platforms/hero/start_snitch.S
new file mode 100644
index 00000000..985fcaa1
--- /dev/null
+++ b/sw/snRuntime/src/platforms/hero/start_snitch.S
@@ -0,0 +1,40 @@
+# Copyright 2020 ETH Zurich and University of Bologna.
+# Licensed under the Apache License, Version 2.0, see LICENSE for details.
+# SPDX-License-Identifier: Apache-2.0
+
+#include "../shared/start_snitch.S"
+
+# Function to terminate execution.
+#
+# Expecting:
+# - a0: exit code
+# - a1: device tree ptr
+_snrt_exit:
+    .globl _snrt_exit
+    # Determine global core index.
+    addi      sp, sp, -8
+    sw        a0, 0(sp)
+    sw        ra, 4(sp)
+    call      snrt_global_core_idx
+    # reload exit code into t0
+    lw        t0, 0(sp)
+    lw        ra, 4(sp)
+    addi      sp, sp, 8
+
+    # Only first core triggers exit.
+    # - a0: global core index
+    # - t0: exit code
+    bnez      a0, 1f
+    slli      t0, t0, 1
+    ori       t0, t0, 1
+    la        t1, tohost
+    sw        t0, 0(t1)
+
+    # Load 1 into a0 to jump out of snRuntime after this function
+    li        a0, 1
+1:  ret
+
+# HTIF sections
+.pushsection .htif,"aw",@progbits;
+.align 6; .global tohost; tohost: .dword 0;
+.align 6; .global fromhost; fromhost: .dword 0;
diff --git a/sw/snRuntime/src/start.S b/sw/snRuntime/src/start.S
index 1574452e..7437a150 100644
--- a/sw/snRuntime/src/start.S
+++ b/sw/snRuntime/src/start.S
@@ -22,6 +22,8 @@ snrt.crt0.init_global_pointer:
     .option pop
 
 snrt.crt0.init_core_info:
+    # Store return address and later push it to the stack
+    mv        s1, ra
     # Information passed into the call:
     # - a0: mhartid (from bootloader)
     # - a1: device tree ptr (from bootloader)
@@ -153,6 +155,10 @@ snrt.crt0.init_tls:
     blt       t0, t2, 1b
 2:
 
+    # Store bootloader return address on top of stack
+    addi      sp, sp, -4
+    sw        s1, 0(sp)
+
     # Initialize the root team.
 snrt.crt0.init_team:
     addi      sp, sp, -20
@@ -193,11 +199,20 @@ snrt.crt0.post_barrier:
     # Write execution result to EOC register.
 snrt.crt0.end:
     mv        a0, s0 # recover return value of main function in s0
+    # Return value
+    # - a0: non-zero instructs jump outside of snRuntime to ra when entered snrt
     call      _snrt_exit
+    bnez      a0, snrt.crt0.exit
 1:
     wfi
     j       1b
 
+snrt.crt0.exit:
+    # load bootloader return address from stack and jump out of snRuntime
+    lw        ra, 0(sp)
+    addi      sp, sp, 4
+    jr        ra
+
 __snrt_crt0_interrupt_handler:
     .align 4
     .globl __snrt_crt0_interrupt_handler
@@ -258,7 +273,7 @@ __snrt_crt0_interrupt_handler:
     fsd     f30, 8(sp)
     fsd     f31, 0(sp)
     # state is stored, can now handle the interrupt
-1:  
+1:
     call    __snrt_isr
     # restore fp context
     csrr    t0, misa
-- 
2.16.5

