From b8cff22d660c99480a0ffd4f1a426b8f75cbb146 Mon Sep 17 00:00:00 2001
From: Noah Huetter <noahhuetter@gmail.com>
Date: Sun, 5 Dec 2021 14:28:41 +0100
Subject: [sw/snitch] conv2d with tracing

Signed-off-by: Noah Huetter <noahhuetter@gmail.com>
---
 sw/applications/src/layers/conv2d_layer.c | 21 +++++++++++++++++++--
 sw/applications/src/utils/utils.h         |  5 +++++
 2 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/sw/applications/src/layers/conv2d_layer.c b/sw/applications/src/layers/conv2d_layer.c
index 0ef4a94..81ece9d 100644
--- a/sw/applications/src/layers/conv2d_layer.c
+++ b/sw/applications/src/layers/conv2d_layer.c
@@ -12,10 +12,13 @@
 #define min(a,b) ((a)<(b)?(a):(b))
 #define max(a,b) ((a)>(b)?(a):(b))
 
+#define _printf(...) if(compute_id==0) printf(__VA_ARGS__)
+// #define _printf(...)
+
 void conv2d_layer(layer l, computeConfig_t *ccfg) {
 
     uint32_t cluster_num = ccfg->cluster_num;
-    uint32_t cluster_id = snrt_cluster_idx();
+    uint32_t cluster_id = ccfg->cluster_idx;
     uint32_t compute_num = ccfg->compute_num;
     uint32_t compute_id = snrt_cluster_compute_core_idx();
 
@@ -294,9 +297,18 @@ void conv2d_layer(layer l, computeConfig_t *ccfg) {
                         snrt_cluster_hw_barrier();
                         benchmark_get_cycle();
 
+                        if(compute_id == 0 && ccfg->cycle_start == 0)
+                            ccfg->cycle_start = read_csr(mcycle);
+                        if(compute_id == 0 && ccfg->max_stmps)
+                            ccfg->stmps[--ccfg->max_stmps] = read_csr(mcycle);
+
                         // Each core performs a matrix multiplication on the im2col buffer
                         // Of size (1 x FHxFWxCI) x (FHxFWxCI x 8), 8 represents CO and is the
                         // unrolling factor needed to prevent RAW conflicts.
+                        // Thus, a  call to `gemm` computes 8 out channels for 1 out pixel over TILCE_CI
+                        // input channels. If CI == TILE_CI, this call completely computes this output
+                        // pixel. CI/TILE_CI calls are required for a complete output pixel.
+                        // Nmm_tot = CO/8 * CI/TILE_CI * OH * OW
                         if (ow + compute_id < l.OW) {
 
                             uint32_t setup_SSR = (ci == 0 && ow == 0 && _oh == 0)? 1 : 0;
@@ -317,8 +329,13 @@ void conv2d_layer(layer l, computeConfig_t *ccfg) {
                                                    &ofmap[write_buf * ofmap_stride + compute_id * ofmap_co_stride], 0, &alpha, setup_SSR);
 
                             }
-
                         }
+
+                        if(compute_id == 0)
+                            ccfg->cycle_end = read_csr(mcycle);
+                        if(compute_id == 0 && ccfg->max_stmps)
+                            ccfg->stmps[--ccfg->max_stmps] = read_csr(mcycle);
+
                         // Toggle read and write buffer
                         read_buf = !read_buf;
                         write_buf = !write_buf;
diff --git a/sw/applications/src/utils/utils.h b/sw/applications/src/utils/utils.h
index bd44d98..ef17bc1 100644
--- a/sw/applications/src/utils/utils.h
+++ b/sw/applications/src/utils/utils.h
@@ -11,6 +11,11 @@ typedef struct computeConfig
 {
     uint32_t cluster_num;
     uint32_t compute_num;
+    uint32_t cluster_idx;
+    uint32_t cycle_start;
+    uint32_t cycle_end;
+    uint32_t *stmps;
+    uint32_t max_stmps;
 } computeConfig_t;
 
 
-- 
2.15.1

