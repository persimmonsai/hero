From 776687ddb2e6031184436b1e53deb45438eb5ff6 Mon Sep 17 00:00:00 2001
From: Noah Huetter <noahhuetter@gmail.com>
Date: Thu, 2 Dec 2021 12:14:30 +0100
Subject: [sw/snitch] Move check layer compute core out of function to mitigate
 FPR stores

Signed-off-by: Noah Huetter <noahhuetter@gmail.com>
---
 sw/applications/src/utils/utils.c | 173 +++++++++++++++++++++-----------------
 1 file changed, 95 insertions(+), 78 deletions(-)

diff --git a/sw/applications/src/utils/utils.c b/sw/applications/src/utils/utils.c
index 75d03b1..9d8ab45 100644
--- a/sw/applications/src/utils/utils.c
+++ b/sw/applications/src/utils/utils.c
@@ -32,6 +32,100 @@ void snrt_dma_start_tracking() { asm volatile ("dmstati t0, 1"); }
  */
 void snrt_dma_stop_tracking() { asm volatile ("dmstati t0, 3"); }
 
+/**
+ * @brief A nested function called in `check_layer` by the compute cores.
+ * This is so that the DM core does not safe float registers
+ */
+static uint32_t __attribute__ ((noinline)) check_layer_compute(layer l, double *checksum) {
+    uint32_t errors = 0;
+    double *ptr = snrt_cluster_memory().start;
+    volatile double *result_buf = ptr;
+    ptr += l.CO;
+    volatile double *ofmap_checksums = ptr;
+    uint32_t total = 0;
+
+    if (snrt_cluster_compute_core_idx() == 0) {
+        snrt_ssr_repeat(SNRT_SSR_DM0, 1);
+
+        // setup SSRs
+        snrt_ssr_loop_1d(SNRT_SSR_DM0, l.CO, sizeof(double));
+
+        for (uint32_t oh = 0; oh < l.OH; oh++) {
+            for (uint32_t ow = 0; ow < l.OW; ow++) {
+                snrt_cluster_hw_barrier();
+
+                double checksum_result = 0.0;
+                const uint32_t ssr = 1;
+
+                if (ssr) {
+                    snrt_ssr_read(SNRT_SSR_DM0, SNRT_SSR_1D,
+                                    result_buf);
+                    snrt_ssr_enable();
+                    register const uint32_t n_frep = l.CO / 8 - 1;
+                    register double checksum_result0 = 0.0;
+                    register double checksum_result1 = 0.0;
+                    register double checksum_result2 = 0.0;
+                    register double checksum_result3 = 0.0;
+                    register double checksum_result4 = 0.0;
+                    register double checksum_result5 = 0.0;
+                    register double checksum_result6 = 0.0;
+                    register double checksum_result7 = 0.0;
+
+                    // frep over OW dimension
+                    asm volatile(
+                        "frep.o %[n_frep], 8, 0, 0 \n"
+                        "fadd.d %[sum0], ft0, %[sum0] \n"
+                        "fadd.d %[sum1], ft0, %[sum1] \n"
+                        "fadd.d %[sum2], ft0, %[sum2] \n"
+                        "fadd.d %[sum3], ft0, %[sum3] \n"
+                        "fadd.d %[sum4], ft0, %[sum4] \n"
+                        "fadd.d %[sum5], ft0, %[sum5] \n"
+                        "fadd.d %[sum6], ft0, %[sum6] \n"
+                        "fadd.d %[sum7], ft0, %[sum7] \n"
+                        : [ sum0 ] "+f"(checksum_result0),
+                            [ sum1 ] "+f"(checksum_result1),
+                            [ sum2 ] "+f"(checksum_result2),
+                            [ sum3 ] "+f"(checksum_result3),
+                            [ sum4 ] "+f"(checksum_result4),
+                            [ sum5 ] "+f"(checksum_result5),
+                            [ sum6 ] "+f"(checksum_result6),
+                            [ sum7 ] "+f"(checksum_result7)
+                        : [ n_frep ] "r"(n_frep)
+                        : "ft0", "ft1", "ft2");
+
+                    snrt_fpu_fence();
+                    snrt_ssr_disable();
+
+                    checksum_result =
+                        checksum_result0 + checksum_result1 +
+                        checksum_result2 + checksum_result3 +
+                        checksum_result4 + checksum_result5 +
+                        checksum_result6 + checksum_result7;
+                } else {
+                    for (uint32_t co = 0; co < l.CO; co++) {
+                        checksum_result += result_buf[co];
+                    }
+                }
+                total++;
+                if (fabs(checksum_result - ofmap_checksums[oh * l.OW + ow]) >
+                    0.001) {
+                    errors++;
+                }
+                snrt_cluster_hw_barrier();
+            }
+        }
+        // printf("%d/%d Errors\n", errors, total);
+    } else {
+        for (uint32_t oh = 0; oh < l.OH; oh++) {
+            for (uint32_t ow = 0; ow < l.OW; ow++) {
+                snrt_cluster_hw_barrier();
+                snrt_cluster_hw_barrier();
+            }
+        }
+    }
+    return errors;
+}
+
 /**
  * @brief checks correctness of feature map
  *
@@ -66,84 +160,7 @@ uint32_t check_layer(layer l, double *checksum) {
                 }
             }
         } else {
-            if (snrt_cluster_compute_core_idx() == 0) {
-                snrt_ssr_repeat(SNRT_SSR_DM0, 1);
-
-                // setup SSRs
-                snrt_ssr_loop_1d(SNRT_SSR_DM0, l.CO, sizeof(double));
-
-                for (uint32_t oh = 0; oh < l.OH; oh++) {
-                    for (uint32_t ow = 0; ow < l.OW; ow++) {
-                        snrt_cluster_hw_barrier();
-
-                        double checksum_result = 0.0;
-                        const uint32_t ssr = 1;
-
-                        if (ssr) {
-                            snrt_ssr_read(SNRT_SSR_DM0, SNRT_SSR_1D,
-                                          result_buf);
-                            snrt_ssr_enable();
-                            register const uint32_t n_frep = l.CO / 8 - 1;
-                            register volatile double checksum_result0 = 0.0;
-                            register volatile double checksum_result1 = 0.0;
-                            register volatile double checksum_result2 = 0.0;
-                            register volatile double checksum_result3 = 0.0;
-                            register volatile double checksum_result4 = 0.0;
-                            register volatile double checksum_result5 = 0.0;
-                            register volatile double checksum_result6 = 0.0;
-                            register volatile double checksum_result7 = 0.0;
-
-                            // frep over OW dimension
-                            asm volatile(
-                                "frep.o %[n_frep], 8, 0, 0 \n"
-                                "fadd.d %[sum0], ft0, %[sum0] \n"
-                                "fadd.d %[sum1], ft0, %[sum1] \n"
-                                "fadd.d %[sum2], ft0, %[sum2] \n"
-                                "fadd.d %[sum3], ft0, %[sum3] \n"
-                                "fadd.d %[sum4], ft0, %[sum4] \n"
-                                "fadd.d %[sum5], ft0, %[sum5] \n"
-                                "fadd.d %[sum6], ft0, %[sum6] \n"
-                                "fadd.d %[sum7], ft0, %[sum7] \n"
-                                : [ sum0 ] "+f"(checksum_result0),
-                                  [ sum1 ] "+f"(checksum_result1),
-                                  [ sum2 ] "+f"(checksum_result2),
-                                  [ sum3 ] "+f"(checksum_result3),
-                                  [ sum4 ] "+f"(checksum_result4),
-                                  [ sum5 ] "+f"(checksum_result5),
-                                  [ sum6 ] "+f"(checksum_result6),
-                                  [ sum7 ] "+f"(checksum_result7)
-                                : [ n_frep ] "r"(n_frep)
-                                : "ft0", "ft1", "ft2");
-
-                            snrt_ssr_disable();
-
-                            checksum_result =
-                                checksum_result0 + checksum_result1 +
-                                checksum_result2 + checksum_result3 +
-                                checksum_result4 + checksum_result5 +
-                                checksum_result6 + checksum_result7;
-                        } else {
-                            for (uint32_t co = 0; co < l.CO; co++) {
-                                checksum_result += result_buf[co];
-                            }
-                        }
-                        total++;
-                        if (fabs(checksum_result - ofmap_checksums[oh * l.OW + ow]) >
-                            0.001) {
-                            errors++;
-                        }
-                        snrt_cluster_hw_barrier();
-                    }
-                }
-                // printf("%d/%d Errors\n", errors, total);
-            } else {
-                for (uint32_t oh = 0; oh < l.OH; oh++) {
-                    for (uint32_t ow = 0; ow < l.OW; ow++) {
-                        snrt_cluster_hw_barrier();
-                        snrt_cluster_hw_barrier();
-                    }
-                }
-            }
+            errors = check_layer_compute(l, checksum);
         }
     }
     return errors;
-- 
2.15.1

