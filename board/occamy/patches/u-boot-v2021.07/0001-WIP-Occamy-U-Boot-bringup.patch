From e2f9b205868e078ad2f8d2be01bac4c4107c6854 Mon Sep 17 00:00:00 2001
From: Roman Pustobaiev <roman@persimmons.ai>
Date: Thu, 12 Oct 2023 14:36:32 +0200
Subject: [PATCH] Patch

---
 arch/arc/lib/relocate.c                 |   2 +
 arch/riscv/Kconfig                      |   4 +
 arch/riscv/dts/Makefile                 |   1 +
 arch/riscv/dts/occamy-u-boot.dtsi       |   1 +
 arch/riscv/dts/occamy.dts               | 152 +++++++++++++++++++++
 arch/riscv/lib/fdt_fixup.c              |   4 +-
 board/pulp-platform/occamy/Kconfig      |  31 +++++
 board/pulp-platform/occamy/Makefile     |   5 +
 board/pulp-platform/occamy/occamy.c     |   5 +
 board/pulp-platform/occamy/occamy_spl.c |  46 +++++++
 common/board_f.c                        |  71 +++++-----
 common/bootm.c                          |   3 +-
 common/console.c                        |  90 ++++++++++++
 common/image.c                          |   5 +-
 common/init/board_init.c                |   8 ++
 common/spl/spl.c                        |   6 +-
 common/spl/spl_fit.c                    |   7 +-
 common/spl/spl_opensbi.c                |  10 +-
 common/xyzModem.c                       |   2 +
 configs/pulp-platform_occamy_defconfig  |  79 +++++++++++
 drivers/core/lists.c                    |  19 +--
 drivers/core/root.c                     |   6 +-
 include/configs/pulp-platform_occamy.h  |  39 ++++++
 include/init.h                          |   5 +
 include/initcall.h                      |   6 +-
 include/log.h                           |   4 +
 lib/display_options.c                   |  10 +-
 lib/fdtdec.c                            | 174 +++++++++++++-----------
 lib/time.c                              |   4 +-
 lib/tiny-printf.c                       |   6 +-
 30 files changed, 661 insertions(+), 144 deletions(-)
 create mode 100644 arch/riscv/dts/occamy-u-boot.dtsi
 create mode 100644 arch/riscv/dts/occamy.dts
 create mode 100644 board/pulp-platform/occamy/Kconfig
 create mode 100644 board/pulp-platform/occamy/Makefile
 create mode 100644 board/pulp-platform/occamy/occamy.c
 create mode 100644 board/pulp-platform/occamy/occamy_spl.c
 create mode 100644 configs/pulp-platform_occamy_defconfig
 create mode 100644 include/configs/pulp-platform_occamy.h

diff --git a/arch/arc/lib/relocate.c b/arch/arc/lib/relocate.c
index 7f531c95ee..694751616d 100644
--- a/arch/arc/lib/relocate.c
+++ b/arch/arc/lib/relocate.c
@@ -35,6 +35,8 @@ int clear_bss(void)
 
 	memset((void *)dst_addr, 0x00, len);
 
+	log_debug("clear_bss: done\\n");
+
 	return 0;
 }
 
diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index b3d7fd84ce..d193ea497d 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -23,6 +23,9 @@ config TARGET_SIFIVE_UNLEASHED
 config TARGET_SIFIVE_UNMATCHED
 	bool "Support SiFive Unmatched Board"
 
+config TARGET_PULP_PLATFORM_OCCAMY
+	bool "Target Occamy Chiplet Architecture"
+
 config TARGET_SIPEED_MAIX
 	bool "Support Sipeed Maix Board"
 
@@ -61,6 +64,7 @@ source "board/microchip/mpfs_icicle/Kconfig"
 source "board/sifive/unleashed/Kconfig"
 source "board/sifive/unmatched/Kconfig"
 source "board/sipeed/maix/Kconfig"
+source "board/pulp-platform/occamy/Kconfig"
 
 # platform-specific options below
 source "arch/riscv/cpu/ax25/Kconfig"
diff --git a/arch/riscv/dts/Makefile b/arch/riscv/dts/Makefile
index 7778874831..04a0fccacf 100644
--- a/arch/riscv/dts/Makefile
+++ b/arch/riscv/dts/Makefile
@@ -6,6 +6,7 @@ dtb-$(CONFIG_TARGET_QEMU_VIRT) += qemu-virt.dtb
 dtb-$(CONFIG_TARGET_SIFIVE_UNLEASHED) += hifive-unleashed-a00.dtb
 dtb-$(CONFIG_TARGET_SIFIVE_UNMATCHED) += hifive-unmatched-a00.dtb
 dtb-$(CONFIG_TARGET_SIPEED_MAIX) += k210-maix-bit.dtb
+dtb-$(CONFIG_TARGET_PULP_PLATFORM_OCCAMY) += occamy.dtb
 
 targets += $(dtb-y)
 
diff --git a/arch/riscv/dts/occamy-u-boot.dtsi b/arch/riscv/dts/occamy-u-boot.dtsi
new file mode 100644
index 0000000000..aa7cdbfb18
--- /dev/null
+++ b/arch/riscv/dts/occamy-u-boot.dtsi
@@ -0,0 +1 @@
+#include "binman.dtsi"
diff --git a/arch/riscv/dts/occamy.dts b/arch/riscv/dts/occamy.dts
new file mode 100644
index 0000000000..83d6db257e
--- /dev/null
+++ b/arch/riscv/dts/occamy.dts
@@ -0,0 +1,152 @@
+// Copyright 2021 ETH Zurich and University of Bologna.
+// Licensed under the Apache License, Version 2.0, see LICENSE for details.
+// SPDX-License-Identifier: Apache-2.0
+
+
+// TODO(niwis) auto generate
+/dts-v1/;
+/ {
+  #address-cells = <2>;
+  #size-cells = <2>;
+  compatible = "eth,occamy-dev";
+  model = "eth,occamy";
+  config {
+    u-boot,spl-payload-offset = <0xa0000000>;
+  };
+  chosen {
+    stdout-path = "/soc/serial@2002000:115200";
+  };
+  memory@80000000 {
+    device_type = "memory";
+    reg = <0x0 0x80000000 0x0 0x30000000>;
+  };
+  // Create a reserved memory regio for Snitch program memory
+  reserved-memory {
+    #address-cells = <2>;
+    #size-cells = <2>;
+    ranges;
+    opensbi:    sbi@80000000 {
+ 	      reg = <0x0 0x80000000 0x0 0x40000>;
+    };
+    snitch_mem: buffer@c0000000 {
+        reg = <0x0 0xc0000000 0x0 0x10000000>;
+    };
+  };
+  cpus {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    timebase-frequency = <10000000>;
+    CPU0: cpu@0 {
+      device_type = "cpu";
+      status = "okay";
+      compatible = "eth,ariane", "riscv";
+      clock-frequency = <50000000>;
+      riscv,isa = "rv64fimafd";
+      mmu-type = "riscv,sv39";
+      tlb-split;
+      reg = <0>;
+      // represents the destination of the mcause bits
+      // ariane has 3 interrupt inputs:
+      // - software (ipi_i[0], IRQ_M_SOFT)
+      // - timer (time_irq_i[0], IRQ_M_TIMER)
+      // - external (irq_i[1:0], {IRQ_S_EXT, IRQ_M_EXT})
+      CPU0_intc: interrupt-controller {
+        #interrupt-cells = <1>;
+        #address-cells = <1>;
+        interrupt-controller;
+        compatible = "riscv,cpu-intc";
+      };
+    };
+  };
+  sysclk: virt_50mhz {
+    #clock-cells = <0>;
+    compatible = "fixed-clock";
+    clock-frequency = <50000000>;
+  };
+  soc: soc {
+    #address-cells = <2>;
+    #size-cells = <2>;
+    compatible = "simple-bus";
+    ranges;
+    debug@0 {
+      compatible = "riscv,debug-013";
+      // interrupts-extended = <&CPU0_intc 65535>;
+      reg-names = "control";
+      reg = <0x0 0x0 0x0 0x1000>;
+    };
+    serial@2002000 {
+      compatible = "ns16550a";
+      reg = <0x0 0x2002000 0x0 0x1000>;
+      clock-frequency = <50000000>;
+      current-speed = <115200>;
+      interrupt-parent = <&PLIC0>;
+      interrupts = <36>;
+      reg-offset = <0>;
+      reg-shift = <2>; // regs are spaced on 32 bit boundary
+      reg-io-width = <4>; // only 32-bit access are supported
+      // fifo-size = <64>;
+    };
+    timer@2006000 {
+      compatible = "pulp,apb_timer";
+      interrupt-parent = <&PLIC0>;
+      interrupts = <0x00000068 0x00000069 0x00000070 0x00000071>;
+      reg = <0x00000000 0x2006000 0x00000000 0x00001000>;
+      reg-names = "control";
+    };
+    clint0: clint@4000000 {
+      clock-frequency = <10000000>;
+      compatible = "riscv,clint0";
+      // clint generates software and timer interrupts to the core. Attach them
+      // to the CPU
+      // bits in mip and exception code in mcause:
+      // - IRQ_M_SOFT = 3: Machine software interrupt
+      // - IRQ_M_TIMER = 7: Machine timer interrupt
+      interrupts-extended = <&CPU0_intc 3 &CPU0_intc 7>;
+      reg-names = "clint";
+      reg = <0x0 0x4000000 0x0 0x100000>;
+    };
+    PLIC0: interrupt-controller@c000000 {
+      compatible = "riscv,plic0";
+      #address-cells = <0>;
+      #interrupt-cells = <1>;
+      interrupt-controller;
+      // PLIC generates external interrupts to the core, M and S mode
+      // - IRQ_M_EXT = 11: Machine external interrupt
+      // - IRQ_S_EXT = 9:  Supervisor external interrupt
+      interrupts-extended = <&CPU0_intc 11 &CPU0_intc 9>;
+      riscv,max-priority = <6>;
+      riscv,ndev = <72>;
+      reg = <0x0 0xc000000 0x0 0x4000000>;
+    };
+    soc_ctl0: soc-control@2000000 {
+      compatible = "eth,occamy-soc-control";
+      reg-names = "soc-control";
+      reg = <0x0 0x02000000 0x0 0x1000>;
+    };
+    quadrant_ctrl0: quadrant-control@b000000 {
+      compatible = "eth,occamy-quadrant-control";
+      reg-names = "quadrant-control";
+      reg = <0x0 0x0b000000 0x0 0x10000>;
+    };
+    // Instantiate a snitch cluster
+    snitch-cluster@10000000 {
+      compatible = "eth,snitch-cluster";
+      // TCDM and Peripheral spaces
+      reg-names = "tcdm", "peripheral";
+      reg = <0x0 0x10000000 0x0 0x20000>, <0x0 0x10020000 0x0 0x20000>;
+      // points to a memory region reserved for use by the cluster
+      memory-region = <&snitch_mem>;
+      // cluster specific properties
+      eth,compute-cores = <8>;
+      eth,dm-cores = <1>;
+      eth,quadrant-idx = <0>;
+      eth,cluster-idx = <0>; // Used to calculate offsets in clint, soc-ctrl etc..
+      // A handle to the soc-control register where isolates etc are located
+      eth,soc-ctl = <&soc_ctl0>;
+      // Handle to the associated quadrant controller
+      eth,quadrant-ctrl = <&quadrant_ctrl0>;
+      // handle to the clint where IPI interrupts are attached
+      eth,clint = <&clint0>;
+    };
+  };
+};
diff --git a/arch/riscv/lib/fdt_fixup.c b/arch/riscv/lib/fdt_fixup.c
index f636b28449..874a75956e 100644
--- a/arch/riscv/lib/fdt_fixup.c
+++ b/arch/riscv/lib/fdt_fixup.c
@@ -166,8 +166,10 @@ int arch_fixup_fdt(void *blob)
 
 	/* Copy the reserved-memory node to the DT used by OS */
 	err = riscv_fdt_copy_resv_mem_node(gd->fdt_blob, blob);
-	if (err < 0)
+	if (err < 0) {
+		log_err("chosen node cannot be copied\n");
 		return err;
+	}
 
 	return 0;
 }
diff --git a/board/pulp-platform/occamy/Kconfig b/board/pulp-platform/occamy/Kconfig
new file mode 100644
index 0000000000..12e0bebe42
--- /dev/null
+++ b/board/pulp-platform/occamy/Kconfig
@@ -0,0 +1,31 @@
+if TARGET_PULP_PLATFORM_OCCAMY
+
+config SYS_BOARD
+	default "occamy"
+
+config SYS_VENDOR
+	default "pulp-platform"
+
+config SYS_CPU
+	default "generic"
+
+config SYS_CONFIG_NAME
+	default "pulp-platform_occamy"
+
+config SYS_TEXT_BASE
+	default 0x80200000 if SPL
+	default 0x80000000 if !RISCV_SMODE
+	default 0x80200000 if RISCV_SMODE
+
+config SPL_TEXT_BASE
+	default 0xb2000000
+
+config SPL_OPENSBI_LOAD_ADDR
+	default 0x80000000
+
+config BOARD_SPECIFIC_OPTIONS # dummy
+	def_bool y
+	select GENERIC_RISCV
+	select SUPPORT_SPL
+
+endif
diff --git a/board/pulp-platform/occamy/Makefile b/board/pulp-platform/occamy/Makefile
new file mode 100644
index 0000000000..fc8f63bbeb
--- /dev/null
+++ b/board/pulp-platform/occamy/Makefile
@@ -0,0 +1,5 @@
+obj-y	+= occamy.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y += occamy_spl.o
+endif
diff --git a/board/pulp-platform/occamy/occamy.c b/board/pulp-platform/occamy/occamy.c
new file mode 100644
index 0000000000..d703634b1a
--- /dev/null
+++ b/board/pulp-platform/occamy/occamy.c
@@ -0,0 +1,5 @@
+#include <init.h>
+
+int board_init(void) { return 0; }
+
+int ft_board_setup(void *fdt, struct bd_info *bd) { return 0; }
diff --git a/board/pulp-platform/occamy/occamy_spl.c b/board/pulp-platform/occamy/occamy_spl.c
new file mode 100644
index 0000000000..6ab6cc129d
--- /dev/null
+++ b/board/pulp-platform/occamy/occamy_spl.c
@@ -0,0 +1,46 @@
+#include <init.h>
+#include <spl.h>
+#include <misc.h>
+#include <log.h>
+#include <asm/spl.h>
+
+int spl_board_init_f(void)
+{
+	_occamy_puts("spl_board_init_f\n");
+
+	return 0;
+}
+
+u32 spl_boot_device(void)
+{
+	return BOOT_DEVICE_RAM;
+}
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	/* boot using first FIT config */
+	return 0;
+}
+#endif
+
+void *memset(void *_ptr, int p, __kernel_size_t size)
+{
+	u8 * ptr = (u8 *)_ptr;
+	for (u32 i = 0; i < size; i++) {
+		ptr[i] = p;
+	}
+	return _ptr;
+}
+
+void *memcpy(void *dest, const void *src, size_t size)
+{
+	unsigned char *dptr = dest;
+	const unsigned char *ptr = src;
+	const unsigned char *end = src + size;
+
+	while (ptr < end)
+		*dptr++ = *ptr++;
+
+	return dest;
+}
\ No newline at end of file
diff --git a/common/board_f.c b/common/board_f.c
index 203e965799..ded367c493 100644
--- a/common/board_f.c
+++ b/common/board_f.c
@@ -149,7 +149,7 @@ static int display_text_info(void)
 	text_base = CONFIG_SYS_MONITOR_BASE;
 #endif
 
-	debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
+	log_debug("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
 	      text_base, bss_start, bss_end);
 #endif
 
@@ -165,7 +165,7 @@ static int print_resetinfo(void)
 
 	ret = uclass_first_device_err(UCLASS_SYSRESET, &dev);
 	if (ret) {
-		debug("%s: No sysreset device found (error: %d)\n",
+		log_debug("%s: No sysreset device found (error: %d)\n",
 		      __func__, ret);
 		/* Not all boards have sysreset drivers available during early
 		 * boot, so don't fail if one can't be found.
@@ -189,14 +189,14 @@ static int print_cpuinfo(void)
 
 	dev = cpu_get_current_dev();
 	if (!dev) {
-		debug("%s: Could not get CPU device\n",
+		log_debug("%s: Could not get CPU device\n",
 		      __func__);
 		return -ENODEV;
 	}
 
 	ret = cpu_get_desc(dev, desc, sizeof(desc));
 	if (ret) {
-		debug("%s: Could not get CPU description (err = %d)\n",
+		log_debug("%s: Could not get CPU description (err = %d)\n",
 		      dev->name, ret);
 		return ret;
 	}
@@ -218,16 +218,16 @@ static int show_dram_config(void)
 	unsigned long long size;
 	int i;
 
-	debug("\nRAM Configuration:\n");
+	log_debug("\nRAM Configuration:\n");
 	for (i = size = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
 		size += gd->bd->bi_dram[i].size;
-		debug("Bank #%d: %llx ", i,
+		log_debug("Bank #%d: %llx ", i,
 		      (unsigned long long)(gd->bd->bi_dram[i].start));
-#ifdef DEBUG
+#ifdef log_debug
 		print_size(gd->bd->bi_dram[i].size, "\n");
 #endif
 	}
-	debug("\nDRAM:  ");
+	log_debug("\nDRAM:  ");
 
 	print_size(size, "");
 	board_add_ram_info(0);
@@ -283,7 +283,7 @@ static int setup_spl_handoff(void)
 #if CONFIG_IS_ENABLED(HANDOFF)
 	gd->spl_handoff = bloblist_find(BLOBLISTT_SPL_HANDOFF,
 					sizeof(struct spl_handoff));
-	debug("Found SPL hand-off info %p\n", gd->spl_handoff);
+	log_debug("Found SPL hand-off info %p\n", gd->spl_handoff);
 #endif
 
 	return 0;
@@ -319,11 +319,11 @@ __weak ulong board_get_usable_ram_top(ulong total_size)
 
 static int setup_dest_addr(void)
 {
-	debug("Monitor len: %08lX\n", gd->mon_len);
+	log_debug("Monitor len: %08lX\n", gd->mon_len);
 	/*
 	 * Ram is setup, size stored in gd !!
 	 */
-	debug("Ram size: %08lX\n", (ulong)gd->ram_size);
+	log_debug("Ram size: %08lX\n", (ulong)gd->ram_size);
 #if defined(CONFIG_SYS_MEM_TOP_HIDE)
 	/*
 	 * Subtract specified amount of memory to hide so that it won't
@@ -343,7 +343,8 @@ static int setup_dest_addr(void)
 	gd->ram_top = gd->ram_base + get_effective_memsize();
 	gd->ram_top = board_get_usable_ram_top(gd->mon_len);
 	gd->relocaddr = gd->ram_top;
-	debug("Ram top: %08lX\n", (ulong)gd->ram_top);
+	log_debug("Ram base: %08lX\n", (ulong)gd->ram_base);
+	log_debug("Ram top: %08lX\n", (ulong)gd->ram_top);
 #if defined(CONFIG_MP) && (defined(CONFIG_MPC86xx) || defined(CONFIG_E500))
 	/*
 	 * We need to make sure the location we intend to put secondary core
@@ -351,7 +352,7 @@ static int setup_dest_addr(void)
 	 */
 	if (gd->relocaddr > determine_mp_bootpg(NULL)) {
 		gd->relocaddr = determine_mp_bootpg(NULL);
-		debug("Reserving MP boot page to %08lx\n", gd->relocaddr);
+		log_debug("Reserving MP boot page to %08lx\n", gd->relocaddr);
 	}
 #endif
 	return 0;
@@ -365,7 +366,7 @@ static int reserve_pram(void)
 
 	reg = env_get_ulong("pram", 10, CONFIG_PRAM);
 	gd->relocaddr -= (reg << 10);		/* size is in kB */
-	debug("Reserving %ldk for protected RAM at %08lx\n", reg,
+	log_debug("Reserving %ldk for protected RAM at %08lx\n", reg,
 	      gd->relocaddr);
 	return 0;
 }
@@ -393,7 +394,7 @@ static int reserve_video(void)
 	ret = video_reserve(&addr);
 	if (ret)
 		return ret;
-	debug("Reserving %luk for video at: %08lx\n",
+	log_debug("Reserving %luk for video at: %08lx\n",
 	      ((unsigned long)gd->relocaddr - addr) >> 10, addr);
 	gd->relocaddr = addr;
 #elif defined(CONFIG_LCD)
@@ -414,7 +415,7 @@ static int reserve_trace(void)
 #ifdef CONFIG_TRACE
 	gd->relocaddr -= CONFIG_TRACE_BUFFER_SIZE;
 	gd->trace_buff = map_sysmem(gd->relocaddr, CONFIG_TRACE_BUFFER_SIZE);
-	debug("Reserving %luk for trace data at: %08lx\n",
+	log_debug("Reserving %luk for trace data at: %08lx\n",
 	      (unsigned long)CONFIG_TRACE_BUFFER_SIZE >> 10, gd->relocaddr);
 #endif
 
@@ -435,7 +436,7 @@ static int reserve_uboot(void)
 		gd->relocaddr &= ~(65536 - 1);
 	#endif
 
-		debug("Reserving %ldk for U-Boot at: %08lx\n",
+		log_debug("Reserving %ldk for U-Boot at: %08lx\n",
 		      gd->mon_len >> 10, gd->relocaddr);
 	}
 
@@ -470,7 +471,7 @@ static int reserve_noncached(void)
 		MMU_SECTION_SIZE;
 	gd->start_addr_sp -= ALIGN(CONFIG_SYS_NONCACHED_MEMORY,
 				   MMU_SECTION_SIZE);
-	debug("Reserving %dM for noncached_alloc() at: %08lx\n",
+	log_debug("Reserving %dM for noncached_alloc() at: %08lx\n",
 	      CONFIG_SYS_NONCACHED_MEMORY >> 20, gd->start_addr_sp);
 
 	return 0;
@@ -481,7 +482,7 @@ static int reserve_noncached(void)
 static int reserve_malloc(void)
 {
 	gd->start_addr_sp = reserve_stack_aligned(TOTAL_MALLOC_LEN);
-	debug("Reserving %dk for malloc() at: %08lx\n",
+	log_debug("Reserving %dk for malloc() at: %08lx\n",
 	      TOTAL_MALLOC_LEN >> 10, gd->start_addr_sp);
 #ifdef CONFIG_SYS_NONCACHED_MEMORY
 	reserve_noncached();
@@ -498,7 +499,7 @@ static int reserve_board(void)
 		gd->bd = (struct bd_info *)map_sysmem(gd->start_addr_sp,
 						      sizeof(struct bd_info));
 		memset(gd->bd, '\0', sizeof(struct bd_info));
-		debug("Reserving %zu Bytes for Board Info at: %08lx\n",
+		log_debug("Reserving %zu Bytes for Board Info at: %08lx\n",
 		      sizeof(struct bd_info), gd->start_addr_sp);
 	}
 	return 0;
@@ -508,7 +509,7 @@ static int reserve_global_data(void)
 {
 	gd->start_addr_sp = reserve_stack_aligned(sizeof(gd_t));
 	gd->new_gd = (gd_t *)map_sysmem(gd->start_addr_sp, sizeof(gd_t));
-	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
+	log_debug("Reserving %zu Bytes for Global Data at: %08lx\n",
 	      sizeof(gd_t), gd->start_addr_sp);
 	return 0;
 }
@@ -526,7 +527,7 @@ static int reserve_fdt(void)
 
 			gd->start_addr_sp = reserve_stack_aligned(gd->fdt_size);
 			gd->new_fdt = map_sysmem(gd->start_addr_sp, gd->fdt_size);
-			debug("Reserving %lu Bytes for FDT at: %08lx\n",
+			log_debug("Reserving %lu Bytes for FDT at: %08lx\n",
 			      gd->fdt_size, gd->start_addr_sp);
 		}
 	}
@@ -541,7 +542,7 @@ static int reserve_bootstage(void)
 
 	gd->start_addr_sp = reserve_stack_aligned(size);
 	gd->new_bootstage = map_sysmem(gd->start_addr_sp, size);
-	debug("Reserving %#x Bytes for bootstage at: %08lx\n", size,
+	log_debug("Reserving %#x Bytes for bootstage at: %08lx\n", size,
 	      gd->start_addr_sp);
 #endif
 
@@ -580,7 +581,7 @@ static int reserve_bloblist(void)
 
 static int display_new_sp(void)
 {
-	debug("New Stack Pointer is: %08lx\n", gd->start_addr_sp);
+	log_debug("New Stack Pointer is: %08lx\n", gd->start_addr_sp);
 
 	return 0;
 }
@@ -639,7 +640,7 @@ static int reloc_bootstage(void)
 	if (gd->new_bootstage) {
 		int size = bootstage_get_size();
 
-		debug("Copying bootstage from %p to %p, size %x\n",
+		log_debug("Copying bootstage from %p to %p, size %x\n",
 		      gd->bootstage, gd->new_bootstage, size);
 		memcpy(gd->new_bootstage, gd->bootstage, size);
 		gd->bootstage = gd->new_bootstage;
@@ -658,7 +659,7 @@ static int reloc_bloblist(void)
 	if (gd->new_bloblist) {
 		int size = CONFIG_BLOBLIST_SIZE;
 
-		debug("Copying bloblist from %p to %p, size %x\n",
+		log_debug("Copying bloblist from %p to %p, size %x\n",
 		      gd->bloblist, gd->new_bloblist, size);
 		bloblist_reloc(gd->new_bloblist, CONFIG_BLOBLIST_SIZE_RELOC,
 			       gd->bloblist, size);
@@ -672,7 +673,7 @@ static int reloc_bloblist(void)
 static int setup_reloc(void)
 {
 	if (gd->flags & GD_FLG_SKIP_RELOC) {
-		debug("Skipping relocation due to flag\n");
+		log_debug("Skipping relocation due to flag\n");
 		return 0;
 	}
 
@@ -691,8 +692,8 @@ static int setup_reloc(void)
 #endif
 	memcpy(gd->new_gd, (char *)gd, sizeof(gd_t));
 
-	debug("Relocation Offset is: %08lx\n", gd->reloc_off);
-	debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
+	log_debug("Relocation Offset is: %08lx\n", gd->reloc_off);
+	log_debug("Relocating to %08lx, new gd at %08lx, sp at %08lx\n",
 	      gd->relocaddr, (ulong)map_to_sysmem(gd->new_gd),
 	      gd->start_addr_sp);
 
@@ -712,8 +713,12 @@ static int fix_fdt(void)
 
 static int jump_to_copy(void)
 {
-	if (gd->flags & GD_FLG_SKIP_RELOC)
+	log_debug("%s\n", __func__);
+
+	if (gd->flags & GD_FLG_SKIP_RELOC) {
+		log_debug("%s : Skipping\n", __func__);
 		return 0;
+	}
 	/*
 	 * x86 is special, but in a nice way. It uses a trampoline which
 	 * enables the dcache if possible.
@@ -755,7 +760,7 @@ static int initf_bootstage(void)
 
 		ret = bootstage_unstash(stash, CONFIG_BOOTSTAGE_STASH_SIZE);
 		if (ret && ret != -ENOENT) {
-			debug("Failed to unstash bootstage: err=%d\n", ret);
+			log_debug("Failed to unstash bootstage: err=%d\n", ret);
 			return ret;
 		}
 	}
@@ -850,7 +855,7 @@ static const init_fnc_t init_sequence_f[] = {
 	serial_init,		/* serial communications setup */
 	console_init_f,		/* stage 1 init of console */
 	display_options,	/* say that we are here */
-	display_text_info,	/* show debugging info if required */
+	display_text_info,	/* show log_debugging info if required */
 	checkcpu,
 #if defined(CONFIG_SYSRESET)
 	print_resetinfo,
@@ -993,7 +998,7 @@ void board_init_f_r(void)
 
 	/*
 	 * The pre-relocation drivers may be using memory that has now gone
-	 * away. Mark serial as unavailable - this will fall back to the debug
+	 * away. Mark serial as unavailable - this will fall back to the log_debug
 	 * UART if available.
 	 *
 	 * Do the same with log drivers since the memory may not be available.
diff --git a/common/bootm.c b/common/bootm.c
index ea71522d0c..8955132af7 100644
--- a/common/bootm.c
+++ b/common/bootm.c
@@ -871,6 +871,7 @@ static const void *boot_get_kernel(struct cmd_tbl *cmdtp, int flag, int argc,
 	/* check image type, for FIT images get FIT kernel node */
 	*os_data = *os_len = 0;
 	buf = map_sysmem(img_addr, 0);
+	printf("%s: Image format = %d\n", __func__, genimg_get_format(buf));
 	switch (genimg_get_format(buf)) {
 #if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)
 	case IMAGE_FORMAT_LEGACY:
@@ -941,7 +942,7 @@ static const void *boot_get_kernel(struct cmd_tbl *cmdtp, int flag, int argc,
 		break;
 #endif
 	default:
-		printf("Wrong Image Format for %s command\n", cmdtp->name);
+		printf("%s: Wrong Image Format for %s command\n", __func__, cmdtp->name);
 		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
 		return NULL;
 	}
diff --git a/common/console.c b/common/console.c
index 561cdf36a7..ed710f256e 100644
--- a/common/console.c
+++ b/common/console.c
@@ -24,6 +24,79 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define OCCAMY_LOG_BASE (0xb9000000)
+#define OCCAMY_IO_MAX_SIZE (1 * 1024 * 512)
+
+#define OCCAMY_INPUT_BASE (OCCAMY_LOG_BASE + OCCAMY_IO_MAX_SIZE)
+#define OCCAMY_INPUT_MAX_SIZE (1 * 1024 * 512)
+
+static unsigned int get_IO_size(unsigned int base) {
+	unsigned int *_log_size = (unsigned int *)(base);
+	return *_log_size;
+}
+
+static void set_IO_size(unsigned int base, int size) {
+	int *_log_size = (int *)(base);
+	*_log_size = *_log_size + size;
+}
+
+static char *get_IO_ptr (unsigned int base, unsigned int *size_remaining) {
+	unsigned int log_size = get_IO_size(base);
+	if (size_remaining) {
+		*size_remaining = (OCCAMY_IO_MAX_SIZE - 8 - log_size);
+	}
+	char *_log_ptr = (char *)(base + 8 + log_size);
+	return _log_ptr;
+}
+
+static int __occamy_putc (const char c) {
+	//Magic
+	unsigned int size_remaining;
+	char *log = get_IO_ptr(OCCAMY_LOG_BASE, &size_remaining);
+	if (size_remaining == 0) {
+		return 0;
+	}
+	*log = c;
+	set_IO_size(OCCAMY_LOG_BASE, 1);
+	return 0;
+}
+
+static int __occamy_puts (const char *msg) {
+	unsigned int char_cnt = 0;
+	unsigned int size_remaining;
+	char *log = get_IO_ptr(OCCAMY_LOG_BASE, &size_remaining);
+	while (*msg && size_remaining) {
+		*log = *msg;
+		log++;
+		msg++;
+		char_cnt++;
+		size_remaining--;
+	}
+	set_IO_size(OCCAMY_LOG_BASE, char_cnt);
+	return 0;
+}
+
+int _occamy_puts (const char *msg) {
+	return __occamy_puts(msg);
+}
+
+int _occamy_putc (const char c) {
+	return __occamy_putc(c);
+}
+
+//Strings come in reversed order
+int _occamy_fgetc (void) {
+	char c;
+	unsigned int size = get_IO_size(OCCAMY_INPUT_BASE);
+	if (!size) {
+		return 0;
+	}
+	char *ptr = get_IO_ptr(OCCAMY_INPUT_BASE, NULL) - 1;
+	c = *ptr;
+	set_IO_size(OCCAMY_INPUT_BASE, -1);
+	return (int)c;
+}
+
 static int on_console(const char *name, const char *value, enum env_op op,
 	int flags)
 {
@@ -479,10 +552,24 @@ int fgetc(int file)
 				 */
 				if (console_has_tstc())
 					return console_getc(file);
+				else {
+					int occamy_c;
+					occamy_c = _occamy_fgetc();
+					if (occamy_c) {
+						return occamy_c;
+					}
+				}
 				console_tstc(file);
 			} else {
 				if (console_tstc(file))
 					return console_getc(file);
+				else {
+					int occamy_c;
+					occamy_c = _occamy_fgetc();
+					if (occamy_c) {
+						return occamy_c;
+					}
+				}
 			}
 
 			/*
@@ -640,6 +727,7 @@ static inline void print_pre_console_buffer(int flushpoint) {}
 
 void putc(const char c)
 {
+	__occamy_putc(c);
 	if (!gd)
 		return;
 
@@ -681,6 +769,8 @@ void putc(const char c)
 
 void puts(const char *s)
 {
+	__occamy_puts(s);
+
 	if (!gd)
 		return;
 
diff --git a/common/image.c b/common/image.c
index 51854aae5d..14884019c4 100644
--- a/common/image.c
+++ b/common/image.c
@@ -1097,6 +1097,7 @@ ulong genimg_get_kernel_addr(char * const img_addr)
  */
 int genimg_get_format(const void *img_addr)
 {
+	int err = 0;
 #if CONFIG_IS_ENABLED(LEGACY_IMAGE_FORMAT)
 	const image_header_t *hdr;
 
@@ -1105,14 +1106,14 @@ int genimg_get_format(const void *img_addr)
 		return IMAGE_FORMAT_LEGACY;
 #endif
 #if IMAGE_ENABLE_FIT || IMAGE_ENABLE_OF_LIBFDT
-	if (fdt_check_header(img_addr) == 0)
+	if ((err = fdt_check_header(img_addr)) == 0)
 		return IMAGE_FORMAT_FIT;
 #endif
 #ifdef CONFIG_ANDROID_BOOT_IMAGE
 	if (android_image_check_header(img_addr) == 0)
 		return IMAGE_FORMAT_ANDROID;
 #endif
-
+	printf("%s: error = %d\n", __func__, err);
 	return IMAGE_FORMAT_INVALID;
 }
 
diff --git a/common/init/board_init.c b/common/init/board_init.c
index 3f183ee113..ba969a9621 100644
--- a/common/init/board_init.c
+++ b/common/init/board_init.c
@@ -87,6 +87,11 @@ ulong board_init_f_alloc_reserve(ulong top)
 	return top;
 }
 
+void clear_log_size(void) {
+	unsigned int *_log_size = (unsigned int *)(OCCAMY_LOG_BASE);
+	*_log_size = 0;
+}
+
 /*
  * Initialize reserved space (which has been safely allocated on the C
  * stack from the C runtime environment handling code).
@@ -138,6 +143,9 @@ void board_init_f_init_reserve(ulong base)
 	 * Use gd_ptr, as gd may not be properly set yet.
 	 */
 
+	//clear_log_size();
+	_occamy_puts("board_init_f_init_reserve\n");
+
 	gd_ptr = (struct global_data *)base;
 	/* zero the area */
 	memset(gd_ptr, '\0', sizeof(*gd));
diff --git a/common/spl/spl.c b/common/spl/spl.c
index a0a608fd77..b016d3014f 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -436,6 +436,7 @@ static int spl_common_init(bool setup_malloc)
 {
 	int ret;
 
+	debug("%s\n", __func__);
 #if CONFIG_VAL(SYS_MALLOC_F_LEN)
 	if (setup_malloc) {
 #ifdef CONFIG_MALLOC_F_ADDR
@@ -510,8 +511,10 @@ int spl_early_init(void)
 	debug("%s\n", __func__);
 
 	ret = spl_common_init(true);
-	if (ret)
+	if (ret) {
+		while (1) {}
 		return ret;
+	}
 	gd->flags |= GD_FLG_SPL_EARLY_INIT;
 
 	return 0;
@@ -731,6 +734,7 @@ void board_init_r(gd_t *dummy1, ulong dummy2)
 #ifdef CONFIG_CPU_V7M
 	spl_image.entry_point |= 0x1;
 #endif
+	debug("*** Preparing to jump : %d\n", spl_image.os);
 	switch (spl_image.os) {
 	case IH_OS_U_BOOT:
 		debug("Jumping to %s...\n", spl_phase_name(spl_next_phase()));
diff --git a/common/spl/spl_fit.c b/common/spl/spl_fit.c
index caddf51196..aed4fdd037 100644
--- a/common/spl/spl_fit.c
+++ b/common/spl/spl_fit.c
@@ -312,17 +312,20 @@ static int spl_load_fit_image(struct spl_load_info *info, ulong sector,
 	}
 
 	if (CONFIG_IS_ENABLED(FIT_SIGNATURE)) {
-		printf("## Checking hash(es) for Image %s ... ",
+		debug("## Checking hash(es) for Image %s ... ",
 		       fit_get_name(fit, node, NULL));
 		if (!fit_image_verify_with_data(fit, node, src, length))
 			return -EPERM;
-		puts("OK\n");
+		debug("OK\n");
 	}
 
 	if (CONFIG_IS_ENABLED(FIT_IMAGE_POST_PROCESS))
 		board_fit_image_post_process(&src, &length);
 
 	load_ptr = map_sysmem(load_addr, length);
+
+	debug("******* %s : load_ptr = %p\n", __func__, load_ptr);
+
 	if (IS_ENABLED(CONFIG_SPL_GZIP) && image_comp == IH_COMP_GZIP) {
 		size = length;
 		if (gunzip(load_ptr, CONFIG_SYS_BOOTM_LEN, src, &size)) {
diff --git a/common/spl/spl_opensbi.c b/common/spl/spl_opensbi.c
index 1c0abf8553..b39199527e 100644
--- a/common/spl/spl_opensbi.c
+++ b/common/spl/spl_opensbi.c
@@ -46,18 +46,19 @@ static int spl_opensbi_find_uboot_node(void *blob, int *uboot_node)
 void spl_invoke_opensbi(struct spl_image_info *spl_image)
 {
 	int ret, uboot_node;
-	ulong uboot_entry;
+	ulong uboot_entry = 0;
 	void (*opensbi_entry)(ulong hartid, ulong dtb, ulong info);
 
+	debug("spl_invoke_opensbi: opensbi_entry=%p\n", spl_image->entry_point);
+
 	if (!spl_image->fdt_addr) {
-		pr_err("No device tree specified in SPL image\n");
+		debug("No device tree specified in SPL image\n");
 		hang();
 	}
-
 	/* Find U-Boot image in /fit-images */
 	ret = spl_opensbi_find_uboot_node(spl_image->fdt_addr, &uboot_node);
 	if (ret) {
-		pr_err("Can't find U-Boot node, %d\n", ret);
+		debug("Can't find U-Boot node, %d\n", ret);
 		hang();
 	}
 
@@ -94,6 +95,7 @@ void spl_invoke_opensbi(struct spl_image_info *spl_image)
 	if (ret)
 		hang();
 #endif
+	debug("Invoking OPENSBI\n");
 	opensbi_entry(gd->arch.boot_hart, (ulong)spl_image->fdt_addr,
 		      (ulong)&opensbi_info);
 }
diff --git a/common/xyzModem.c b/common/xyzModem.c
index fc3459ebba..d8d29d2e09 100644
--- a/common/xyzModem.c
+++ b/common/xyzModem.c
@@ -493,6 +493,8 @@ xyzModem_stream_read (char *buf, int size, int *err)
 
   total = 0;
   stat = xyzModem_cancel;
+
+  debug("xyzModem_stream_read\n");
   /* Try and get 'size' bytes into the buffer */
   while (!xyz.at_eof && (size > 0))
     {
diff --git a/configs/pulp-platform_occamy_defconfig b/configs/pulp-platform_occamy_defconfig
new file mode 100644
index 0000000000..f6804829d4
--- /dev/null
+++ b/configs/pulp-platform_occamy_defconfig
@@ -0,0 +1,79 @@
+CONFIG_RISCV=y
+CONFIG_SYS_MALLOC_F_LEN=0x3000
+#CONFIG_DM_GPIO is not set
+#CONFIG_SPL_DM_SPI is not set
+CONFIG_SPL=y
+#CONFIG_SPL_SPI_FLASH_SUPPORT is not set
+#CONFIG_SPL_SPI_SUPPORT is not set
+CONFIG_DEFAULT_DEVICE_TREE="occamy"
+CONFIG_TARGET_PULP_PLATFORM_OCCAMY=y
+CONFIG_ARCH_RV64I=y
+CONFIG_RISCV_SMODE=y
+CONFIG_FIT=y
+CONFIG_SPL_LOAD_FIT_ADDRESS=0xa0000000
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_BOOTDELAY=1
+#CONFIG_USE_BOOTCOMMAND is not set
+#CONFIG_BOOTCOMMAND="dhcp; tftp 0x83000000 129.132.24.199:vcu128-01/Image.itb; bootm 0x83000000"
+CONFIG_USE_BOOTARGS=y
+CONFIG_BOOTARGS="earlyprintk"
+CONFIG_LOG=y
+CONFIG_LOG_MAX_LEVEL=9
+CONFIG_LOGF_FUNC=y
+CONFIG_LOG_ERROR_RETURN=y
+CONFIG_DISPLAY_CPUINFO=y
+#CONFIG_SPL_MTD_SUPPORT is not set
+#CONFIG_SPL_DM_SPI_FLASH is not set
+CONFIG_SPL_RAM_SUPPORT=y
+CONFIG_SPL_RAM_DEVICE=y
+#CONFIG_SPL_SPI_FLASH_MTD is not set
+#CONFIG_SPL_SPI_LOAD is not set
+#CONFIG_CMD_MEMTEST is not set
+#CONFIG_CMD_GPIO is not set
+#CONFIG_CMD_I2C is not set
+CONFIG_CMD_SF_TEST=y
+#CONFIG_CMD_AXI is not set
+#CONFIG_CMD_DHCP is not set
+#CONFIG_CMD_MII is not set
+#CONFIG_CMD_PING is not set
+#CONFIG_CMD_DNS is not set
+#CONFIG_CMD_MTDPARTS is not set
+CONFIG_CMD_FDT=y
+CONFIG_MTDIDS_DEFAULT="ramdisk0=ramdisk0.0"
+CONFIG_MTDPARTS_DEFAULT="mtdparts=ramdisk0.0:1m(u-boot),16m(uimage),143m(filesystem)"
+CONFIG_OF_PRIOR_STAGE=y
+#CONFIG_PROT_UDP is not set
+#CONFIG_NET_RANDOM_ETHADDR is not set
+#CONFIG_AXI is not set
+#CONFIG_DM_PCA953X is not set
+#CONFIG_DM_I2C is not set
+#CONFIG_SYS_I2C_XILINX_XIIC is not set
+#CONFIG_I2C_MUX is not set
+#CONFIG_I2C_MUX_PCA954x is not set
+#CONFIG_DM_MTD is not set
+#CONFIG_SPI_FLASH_ATMEL is not set
+#CONFIG_SPI_FLASH_EON is not set
+#CONFIG_SPI_FLASH_GIGADEVICE is not set
+#CONFIG_SPI_FLASH_ISSI is not set
+#CONFIG_SPI_FLASH_MACRONIX is not set
+#CONFIG_SPI_FLASH_SPANSION is not set
+#CONFIG_SPI_FLASH_STMICRO is not set
+#CONFIG_SPI_FLASH_SST is not set
+#CONFIG_SPI_FLASH_WINBOND is not set
+#CONFIG_SPI_FLASH_XMC is not set
+# CONFIG_SPI_FLASH_USE_4K_SECTORS is not set
+#CONFIG_SPI_FLASH_MTD is not set
+#CONFIG_PHY_TI_DP83867 is not set
+#CONFIG_PHY_XILINX is not set
+#CONFIG_DM_MDIO is not set
+#CONFIG_DM_ETH_PHY is not set
+#CONFIG_XILINX_AXIEMAC is not set
+#CONFIG_PHY is not set
+CONFIG_SYS_NS16550=y
+#CONFIG_SPI is not set
+#CONFIG_XILINX_SPI is not set
+CONFIG_CLINT_TIMER=y
+#CONFIG_SPL_OS_BOOT is not set
+CONFIG_FIT_SIGNATURE=y
+CONFIG_USE_TINY_PRINTF=y
+CONFIG_PRINTF=y
\ No newline at end of file
diff --git a/drivers/core/lists.c b/drivers/core/lists.c
index e214306b90..b52377eace 100644
--- a/drivers/core/lists.c
+++ b/drivers/core/lists.c
@@ -198,17 +198,18 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 	if (devp)
 		*devp = NULL;
 	name = ofnode_get_name(node);
-	log_debug("bind node %s\n", name);
+
+	debug("bind node, name = \"%s\"\n", name);
 
 	compat_list = ofnode_get_property(node, "compatible", &compat_length);
 	if (!compat_list) {
 		if (compat_length == -FDT_ERR_NOTFOUND) {
-			log_debug("Device '%s' has no compatible string\n",
+			debug("Device '%s' has no compatible string\n",
 				  name);
 			return 0;
 		}
 
-		dm_warn("Device tree error at node '%s'\n", name);
+		debug("Device tree error at node '%s'\n", name);
 		return compat_length;
 	}
 
@@ -219,7 +220,7 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 	 */
 	for (i = 0; i < compat_length; i += strlen(compat) + 1) {
 		compat = compat_list + i;
-		log_debug("   - attempt to match compatible string '%s'\n",
+		debug("   - attempt to match compatible string '%s'\n",
 			  compat);
 
 		for (entry = driver; entry != driver + n_ents; entry++) {
@@ -234,22 +235,22 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 		if (pre_reloc_only) {
 			if (!ofnode_pre_reloc(node) &&
 			    !(entry->flags & DM_FLAG_PRE_RELOC)) {
-				log_debug("Skipping device pre-relocation\n");
+				debug("Skipping device pre-relocation\n");
 				return 0;
 			}
 		}
 
-		log_debug("   - found match at '%s': '%s' matches '%s'\n",
+		debug("   - found match at '%s': '%s' matches '%s'\n",
 			  entry->name, entry->of_match->compatible,
 			  id->compatible);
 		ret = device_bind_with_driver_data(parent, entry, name,
 						   id->data, node, &dev);
 		if (ret == -ENODEV) {
-			log_debug("Driver '%s' refuses to bind\n", entry->name);
+			debug("Driver '%s' refuses to bind\n", entry->name);
 			continue;
 		}
 		if (ret) {
-			dm_warn("Error binding driver '%s': %d\n", entry->name,
+			debug("Error binding driver '%s': %d\n", entry->name,
 				ret);
 			return log_msg_ret("bind", ret);
 		} else {
@@ -261,7 +262,7 @@ int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
 	}
 
 	if (!found && !result && ret != -ENODEV)
-		log_debug("No match for node '%s'\n", name);
+		debug("No match for node '%s'\n", name);
 
 	return result;
 }
diff --git a/drivers/core/root.c b/drivers/core/root.c
index fe0562cd6f..f74f045e87 100644
--- a/drivers/core/root.c
+++ b/drivers/core/root.c
@@ -273,8 +273,10 @@ static int dm_scan_fdt_node(struct udevice *parent, ofnode parent_node,
 	     node = ofnode_next_subnode(node)) {
 		const char *node_name = ofnode_get_name(node);
 
+		debug("dm_scan_fdt_node: node name =  \"%s\"\n", node_name);
+
 		if (!ofnode_is_enabled(node)) {
-			pr_debug("   - ignoring disabled device\n");
+			debug("   - ignoring disabled device\n");
 			continue;
 		}
 		err = lists_bind_fdt(parent, node, NULL, pre_reloc_only);
@@ -400,7 +402,7 @@ int dm_init_and_scan(bool pre_reloc_only)
 	if (!CONFIG_IS_ENABLED(OF_PLATDATA_INST)) {
 		ret = dm_scan(pre_reloc_only);
 		if (ret) {
-			log_debug("dm_scan() failed: %d\n", ret);
+			debug("dm_scan() failed: %d\n", ret);
 			return ret;
 		}
 	}
diff --git a/include/configs/pulp-platform_occamy.h b/include/configs/pulp-platform_occamy.h
new file mode 100644
index 0000000000..291f584952
--- /dev/null
+++ b/include/configs/pulp-platform_occamy.h
@@ -0,0 +1,39 @@
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <linux/sizes.h>
+
+#define CONFIG_TFTP_TSIZE
+
+// fdt_high=~0UL to use FDT in-place
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"fdt_high=0xb0000000\0" \
+	"" \
+	""
+
+#ifdef CONFIG_SPL
+#define CONFIG_SPL_MAX_SIZE		0x00020000
+
+#define CONFIG_SPL_BSS_START_ADDR	0xb2018000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x00008000
+
+// We need more space than the SPM can provide, so put the heap into HBM.
+// malloc should only be available _after_ the HBM is initialised.
+#define CONFIG_SYS_SPL_MALLOC_START	0xb4000000
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x00100000
+
+#define CONFIG_SPL_STACK	0xb2018000
+#endif
+
+// OpenSBI is at 0x80000000
+#define CONFIG_SYS_SDRAM_BASE		0x80200000
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_SDRAM_BASE + SZ_2M)
+
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + SZ_2M)
+
+#define CONFIG_SYS_MALLOC_LEN       SZ_8M
+#define CONFIG_SYS_BOOTM_LEN        SZ_128M
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 1
+#define CONFIG_SYS_FLASH_BASE 0x0
+#endif
diff --git a/include/init.h b/include/init.h
index fd51d7f966..287b796576 100644
--- a/include/init.h
+++ b/include/init.h
@@ -10,6 +10,11 @@
 #ifndef __INIT_H_
 #define __INIT_H_	1
 
+#define OCCAMY_LOG_BASE (0xb9000000)
+
+int _occamy_puts (const char *msg);
+int _occamy_putc (const char c);
+
 #ifndef __ASSEMBLY__		/* put C only stuff in this section */
 
 #include <linux/types.h>
diff --git a/include/initcall.h b/include/initcall.h
index 69ce268070..88704cd825 100644
--- a/include/initcall.h
+++ b/include/initcall.h
@@ -37,15 +37,15 @@ static inline int initcall_run_list(const init_fnc_t init_sequence[])
 		reloc_ofs = (unsigned long)image_base;
 #endif
 		if (reloc_ofs)
-			debug("initcall: %p (relocated to %p)\n",
+			log_debug("initcall: %p (relocated to %p)\n",
 					(char *)*init_fnc_ptr - reloc_ofs,
 					(char *)*init_fnc_ptr);
 		else
-			debug("initcall: %p\n", (char *)*init_fnc_ptr - reloc_ofs);
+			log_debug("initcall: %p\n", (char *)*init_fnc_ptr - reloc_ofs);
 
 		ret = (*init_fnc_ptr)();
 		if (ret) {
-			printf("initcall sequence %p failed at call %p (err=%d)\n",
+			log_debug("initcall sequence %p failed at call %p (err=%d)\n",
 			       init_sequence,
 			       (char *)*init_fnc_ptr - reloc_ofs, ret);
 			return -1;
diff --git a/include/log.h b/include/log.h
index add3a1e4a0..5b39d21e51 100644
--- a/include/log.h
+++ b/include/log.h
@@ -210,6 +210,10 @@ static inline int _log_nop(enum log_category_t cat, enum log_level_t level,
 		      __func__, pr_fmt(_fmt), ##_args); \
 })
 
+#ifndef DEBUG
+#define DEBUG
+#endif
+
 #ifdef DEBUG
 #define _DEBUG	1
 #else
diff --git a/lib/display_options.c b/lib/display_options.c
index cd48998b6d..cb7cdb6bfb 100644
--- a/lib/display_options.c
+++ b/lib/display_options.c
@@ -153,7 +153,7 @@ int print_buffer(ulong addr, const void *data, uint width, uint count,
 
 	while (count) {
 		uint thislinelen = linelen;
-		printf("%08lx:", addr);
+		debug("%08lx:", addr);
 
 		/* check for overflow condition */
 		if (count < thislinelen)
@@ -170,16 +170,16 @@ int print_buffer(ulong addr, const void *data, uint width, uint count,
 			else
 				x = lb.uc[i] = *(volatile uint8_t *)data;
 			if (CONFIG_IS_ENABLED(USE_TINY_PRINTF))
-				printf(" %x", (uint)x);
+				debug(" %x", (uint)x);
 			else
-				printf(" %0*lx", width * 2, x);
+				debug(" %0*lx", width * 2, x);
 			data += width;
 		}
 
 		while (thislinelen < linelen) {
 			/* fill line with whitespace for nice ASCII print */
 			for (i=0; i<width*2+1; i++)
-				puts(" ");
+				debug(" ");
 			linelen--;
 		}
 
@@ -189,7 +189,7 @@ int print_buffer(ulong addr, const void *data, uint width, uint count,
 				lb.uc[i] = '.';
 		}
 		lb.uc[i] = '\0';
-		printf("    %s\n", lb.uc);
+		debug("    %s\n", lb.uc);
 
 		/* update references */
 		addr += thislinelen * width;
diff --git a/lib/fdtdec.c b/lib/fdtdec.c
index 4b097fb588..3a35d707e8 100644
--- a/lib/fdtdec.c
+++ b/lib/fdtdec.c
@@ -95,11 +95,11 @@ fdt_addr_t fdtdec_get_addr_size_fixed(const void *blob, int node,
 	int len;
 	fdt_addr_t addr;
 
-	debug("%s: %s: ", __func__, prop_name);
+	log_debug("%s: %s: ", __func__, prop_name);
 
 	prop = fdt_getprop(blob, node, prop_name, &len);
 	if (!prop) {
-		debug("(not found)\n");
+		log_debug("(not found)\n");
 		return FDT_ADDR_T_NONE;
 	}
 	prop_end = prop + (len / sizeof(*prop));
@@ -108,7 +108,7 @@ fdt_addr_t fdtdec_get_addr_size_fixed(const void *blob, int node,
 	prop_size = prop_addr + na;
 	prop_after_size = prop_size + ns;
 	if (prop_after_size > prop_end) {
-		debug("(not enough data: expected >= %d cells, got %d cells)\n",
+		log_debug("(not enough data: expected >= %d cells, got %d cells)\n",
 		      (u32)(prop_after_size - prop), ((u32)(prop_end - prop)));
 		return FDT_ADDR_T_NONE;
 	}
@@ -122,10 +122,10 @@ fdt_addr_t fdtdec_get_addr_size_fixed(const void *blob, int node,
 
 	if (sizep) {
 		*sizep = fdtdec_get_number(prop_size, ns);
-		debug("addr=%08llx, size=%llx\n", (unsigned long long)addr,
+		log_debug("addr=%08llx, size=%llx\n", (unsigned long long)addr,
 		      (unsigned long long)*sizep);
 	} else {
-		debug("addr=%08llx\n", (unsigned long long)addr);
+		log_debug("addr=%08llx\n", (unsigned long long)addr);
 	}
 
 	return addr;
@@ -138,21 +138,21 @@ fdt_addr_t fdtdec_get_addr_size_auto_parent(const void *blob, int parent,
 {
 	int na, ns;
 
-	debug("%s: ", __func__);
+	log_debug("%s: ", __func__);
 
 	na = fdt_address_cells(blob, parent);
 	if (na < 1) {
-		debug("(bad #address-cells)\n");
+		log_debug("(bad #address-cells)\n");
 		return FDT_ADDR_T_NONE;
 	}
 
 	ns = fdt_size_cells(blob, parent);
 	if (ns < 0) {
-		debug("(bad #size-cells)\n");
+		log_debug("(bad #size-cells)\n");
 		return FDT_ADDR_T_NONE;
 	}
 
-	debug("na=%d, ns=%d, ", na, ns);
+	log_debug("na=%d, ns=%d, ", na, ns);
 
 	return fdtdec_get_addr_size_fixed(blob, node, prop_name, index, na,
 					  ns, sizep, translate);
@@ -165,11 +165,11 @@ fdt_addr_t fdtdec_get_addr_size_auto_noparent(const void *blob, int node,
 {
 	int parent;
 
-	debug("%s: ", __func__);
+	log_debug("%s: ", __func__);
 
 	parent = fdt_parent_offset(blob, node);
 	if (parent < 0) {
-		debug("(no parent found)\n");
+		log_debug("(no parent found)\n");
 		return FDT_ADDR_T_NONE;
 	}
 
@@ -384,7 +384,7 @@ int fdtdec_add_aliases_for_id(const void *blob, const char *name,
 			nodes[count++] = node;
 	}
 	if (node >= 0)
-		debug("%s: warning: maxcount exceeded with alias '%s'\n",
+		log_debug("%s: warning: maxcount exceeded with alias '%s'\n",
 		      __func__, name);
 
 	/* Now find all the aliases */
@@ -407,7 +407,7 @@ int fdtdec_add_aliases_for_id(const void *blob, const char *name,
 		/* Get the alias number */
 		number = simple_strtoul(path + name_len, NULL, 10);
 		if (number < 0 || number >= maxcount) {
-			debug("%s: warning: alias '%s' is out of range\n",
+			log_debug("%s: warning: alias '%s' is out of range\n",
 			      __func__, path);
 			continue;
 		}
@@ -421,7 +421,7 @@ int fdtdec_add_aliases_for_id(const void *blob, const char *name,
 			}
 
 		if (found == -1) {
-			debug("%s: warning: alias '%s' points to a node "
+			log_debug("%s: warning: alias '%s' points to a node "
 				"'%s' that is missing or is not compatible "
 				" with '%s'\n", __func__, path,
 				fdt_get_name(blob, node, NULL),
@@ -435,7 +435,7 @@ int fdtdec_add_aliases_for_id(const void *blob, const char *name,
 		 */
 		if (fdtdec_get_is_enabled(blob, node)) {
 			if (node_list[number]) {
-				debug("%s: warning: alias '%s' requires that "
+				log_debug("%s: warning: alias '%s' requires that "
 				      "a node be placed in the list in a "
 				      "position which is already filled by "
 				      "node '%s'\n", __func__, path,
@@ -481,7 +481,7 @@ int fdtdec_get_alias_seq(const void *blob, const char *base, int offset,
 	int aliases;
 
 	find_name = fdt_get_name(blob, offset, &find_namelen);
-	debug("Looking for '%s' at %d, name %s\n", base, offset, find_name);
+	log_debug("Looking for '%s' at %d, name %s\n", base, offset, find_name);
 
 	aliases = fdt_path_offset(blob, "/aliases");
 	for (prop_offset = fdt_first_property_offset(blob, aliases);
@@ -493,7 +493,7 @@ int fdtdec_get_alias_seq(const void *blob, const char *base, int offset,
 		int len, val;
 
 		prop = fdt_getprop_by_offset(blob, prop_offset, &name, &len);
-		debug("   - %s, %s\n", name, prop);
+		log_debug("   - %s, %s\n", name, prop);
 		if (len < find_namelen || *prop != '/' || prop[len - 1] ||
 		    strncmp(name, base, base_len))
 			continue;
@@ -515,12 +515,12 @@ int fdtdec_get_alias_seq(const void *blob, const char *base, int offset,
 		val = trailing_strtol(name);
 		if (val != -1) {
 			*seqp = val;
-			debug("Found seq %d\n", *seqp);
+			log_debug("Found seq %d\n", *seqp);
 			return 0;
 		}
 	}
 
-	debug("Not found\n");
+	log_debug("Not found\n");
 	return -ENOENT;
 }
 
@@ -531,7 +531,7 @@ int fdtdec_get_alias_highest_id(const void *blob, const char *base)
 	int aliases;
 	int max = -1;
 
-	debug("Looking for highest alias id for '%s'\n", base);
+	log_debug("Looking for highest alias id for '%s'\n", base);
 
 	aliases = fdt_path_offset(blob, "/aliases");
 	for (prop_offset = fdt_first_property_offset(blob, aliases);
@@ -542,14 +542,14 @@ int fdtdec_get_alias_highest_id(const void *blob, const char *base)
 		int len, val;
 
 		prop = fdt_getprop_by_offset(blob, prop_offset, &name, &len);
-		debug("   - %s, %s\n", name, prop);
+		log_debug("   - %s, %s\n", name, prop);
 		if (*prop != '/' || prop[len - 1] ||
 		    strncmp(name, base, base_len))
 			continue;
 
 		val = trailing_strtol(name);
 		if (val > max) {
-			debug("Found seq %d\n", val);
+			log_debug("Found seq %d\n", val);
 			max = val;
 		}
 	}
@@ -596,16 +596,18 @@ int fdtdec_check_fdt(void)
  */
 int fdtdec_prepare_fdt(void)
 {
+	int header;
 	if (!gd->fdt_blob || ((uintptr_t)gd->fdt_blob & 3) ||
-	    fdt_check_header(gd->fdt_blob)) {
+	    (header = fdt_check_header(gd->fdt_blob))) {
+		log_debug("fdt_check_header: return code = %d\n", header);
 #ifdef CONFIG_SPL_BUILD
-		puts("Missing DTB\n");
+		log_debug("Missing DTB\n");
 #else
-		printf("No valid device tree binary found at %p\n",
+		log_debug("No valid device tree binary found at %p\n",
 		       gd->fdt_blob);
-# ifdef DEBUG
+# ifdef log_debug
 		if (gd->fdt_blob) {
-			printf("fdt_blob=%p\n", gd->fdt_blob);
+			log_debug("fdt_blob=%p\n", gd->fdt_blob);
 			print_buffer((ulong)gd->fdt_blob, gd->fdt_blob, 4,
 				     32, 0);
 		}
@@ -621,7 +623,7 @@ int fdtdec_lookup_phandle(const void *blob, int node, const char *prop_name)
 	const u32 *phandle;
 	int lookup;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	phandle = fdt_getprop(blob, node, prop_name, NULL);
 	if (!phandle)
 		return -FDT_ERR_NOTFOUND;
@@ -648,7 +650,7 @@ static const void *get_prop_check_min_len(const void *blob, int node,
 	const void *cell;
 	int len;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	cell = fdt_getprop(blob, node, prop_name, &len);
 	if (!cell)
 		*err = -FDT_ERR_NOTFOUND;
@@ -665,7 +667,7 @@ int fdtdec_get_int_array(const void *blob, int node, const char *prop_name,
 	const u32 *cell;
 	int err = 0;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	cell = get_prop_check_min_len(blob, node, prop_name,
 				      sizeof(u32) * count, &err);
 	if (!err) {
@@ -684,7 +686,7 @@ int fdtdec_get_int_array_count(const void *blob, int node,
 	int len, elems;
 	int i;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	cell = fdt_getprop(blob, node, prop_name, &len);
 	if (!cell)
 		return -FDT_ERR_NOTFOUND;
@@ -713,7 +715,7 @@ int fdtdec_get_bool(const void *blob, int node, const char *prop_name)
 	const s32 *cell;
 	int len;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	cell = fdt_getprop(blob, node, prop_name, &len);
 	return cell != NULL;
 }
@@ -760,7 +762,7 @@ int fdtdec_parse_phandle_with_args(const void *blob, int src_node,
 				node = fdt_node_offset_by_phandle(blob,
 								  phandle);
 				if (node < 0) {
-					debug("%s: could not find phandle\n",
+					log_debug("%s: could not find phandle\n",
 					      fdt_get_name(blob, src_node,
 							   NULL));
 					goto err;
@@ -771,7 +773,7 @@ int fdtdec_parse_phandle_with_args(const void *blob, int src_node,
 				count = fdtdec_get_int(blob, node, cells_name,
 						       -1);
 				if (count == -1) {
-					debug("%s: could not get %s for %s\n",
+					log_debug("%s: could not get %s for %s\n",
 					      fdt_get_name(blob, src_node,
 							   NULL),
 					      cells_name,
@@ -788,7 +790,7 @@ int fdtdec_parse_phandle_with_args(const void *blob, int src_node,
 			 * remaining property data length
 			 */
 			if (list + count > list_end) {
-				debug("%s: arguments longer than property\n",
+				log_debug("%s: arguments longer than property\n",
 				      fdt_get_name(blob, src_node, NULL));
 				goto err;
 			}
@@ -809,7 +811,7 @@ int fdtdec_parse_phandle_with_args(const void *blob, int src_node,
 				int i;
 
 				if (count > MAX_PHANDLE_ARGS) {
-					debug("%s: too many arguments %d\n",
+					log_debug("%s: too many arguments %d\n",
 					      fdt_get_name(blob, src_node,
 							   NULL), count);
 					count = MAX_PHANDLE_ARGS;
@@ -871,7 +873,7 @@ int fdtdec_get_config_int(const void *blob, const char *prop_name,
 {
 	int config_node;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	config_node = fdt_path_offset(blob, "/config");
 	if (config_node < 0)
 		return default_val;
@@ -883,7 +885,7 @@ int fdtdec_get_config_bool(const void *blob, const char *prop_name)
 	int config_node;
 	const void *prop;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	config_node = fdt_path_offset(blob, "/config");
 	if (config_node < 0)
 		return 0;
@@ -898,7 +900,7 @@ char *fdtdec_get_config_string(const void *blob, const char *prop_name)
 	int nodeoffset;
 	int len;
 
-	debug("%s: %s\n", __func__, prop_name);
+	log_debug("%s: %s\n", __func__, prop_name);
 	nodeoffset = fdt_path_offset(blob, "/config");
 	if (nodeoffset < 0)
 		return NULL;
@@ -980,7 +982,7 @@ static int decode_timing_property(const void *blob, int node, const char *name,
 
 	prop = fdt_getprop(blob, node, name, &length);
 	if (!prop) {
-		debug("%s: could not find property %s\n",
+		log_debug("%s: could not find property %s\n",
 		      fdt_get_name(blob, node, NULL), name);
 		return length;
 	}
@@ -1072,20 +1074,20 @@ int fdtdec_setup_mem_size_base(void)
 
 	mem = ofnode_path("/memory");
 	if (!ofnode_valid(mem)) {
-		debug("%s: Missing /memory node\n", __func__);
+		log_debug("%s: Missing /memory node\n", __func__);
 		return -EINVAL;
 	}
 
 	ret = ofnode_read_resource(mem, 0, &res);
 	if (ret != 0) {
-		debug("%s: Unable to decode first memory bank\n", __func__);
+		log_debug("%s: Unable to decode first memory bank\n", __func__);
 		return -EINVAL;
 	}
 
 	gd->ram_size = (phys_size_t)(res.end - res.start + 1);
 	gd->ram_base = (unsigned long)res.start;
-	debug("%s: Initial DRAM size %llx\n", __func__,
-	      (unsigned long long)gd->ram_size);
+	log_debug("%s: Initial DRAM size %llx, DRAM base = %llx\n", __func__,
+	      (unsigned long long)gd->ram_size, (unsigned long long)res.start);
 
 	return 0;
 }
@@ -1107,7 +1109,7 @@ int fdtdec_setup_memory_banksize(void)
 
 	mem = get_next_memory_node(mem);
 	if (!ofnode_valid(mem)) {
-		debug("%s: Missing /memory node\n", __func__);
+		log_debug("%s: Missing /memory node\n", __func__);
 		return -EINVAL;
 	}
 
@@ -1131,7 +1133,7 @@ int fdtdec_setup_memory_banksize(void)
 		gd->bd->bi_dram[bank].size =
 			(phys_size_t)(res.end - res.start + 1);
 
-		debug("%s: DRAM Bank #%d: start = 0x%llx, size = 0x%llx\n",
+		log_debug("%s: DRAM Bank #%d: start = 0x%llx, size = 0x%llx\n",
 		      __func__, bank,
 		      (unsigned long long)gd->bd->bi_dram[bank].start,
 		      (unsigned long long)gd->bd->bi_dram[bank].size);
@@ -1152,7 +1154,7 @@ int fdtdec_setup_mem_size_base_lowest(void)
 
 	mem = get_next_memory_node(mem);
 	if (!ofnode_valid(mem)) {
-		debug("%s: Missing /memory node\n", __func__);
+		log_debug("%s: Missing /memory node\n", __func__);
 		return -EINVAL;
 	}
 
@@ -1178,7 +1180,7 @@ int fdtdec_setup_mem_size_base_lowest(void)
 		if (gd->ram_base > base && size) {
 			gd->ram_base = base;
 			gd->ram_size = size;
-			debug("%s: Initial DRAM base %lx size %lx\n",
+			log_debug("%s: Initial DRAM base %lx size %lx\n",
 			      __func__, base, (unsigned long)size);
 		}
 	}
@@ -1282,11 +1284,11 @@ int fdtdec_set_ethernet_mac_address(void *fdt, const u8 *mac, size_t size)
 	if (!path)
 		return 0;
 
-	debug("ethernet alias found: %s\n", path);
+	log_debug("ethernet alias found: %s\n", path);
 
 	offset = fdt_path_offset(fdt, path);
 	if (offset < 0) {
-		debug("ethernet alias points to absent node %s\n", path);
+		log_debug("ethernet alias points to absent node %s\n", path);
 		return -ENOENT;
 	}
 
@@ -1294,7 +1296,7 @@ int fdtdec_set_ethernet_mac_address(void *fdt, const u8 *mac, size_t size)
 	if (err < 0)
 		return err;
 
-	debug("MAC address: %pM\n", mac);
+	log_debug("MAC address: %pM\n", mac);
 
 	return 0;
 }
@@ -1341,12 +1343,16 @@ int fdtdec_add_reserved_memory(void *blob, const char *basename,
 	fdt_size_t size;
 	char name[64];
 
+	log_debug("%s\n", __func__);
+
 	/* create an empty /reserved-memory node if one doesn't exist */
 	parent = fdt_path_offset(blob, "/reserved-memory");
 	if (parent < 0) {
 		parent = fdtdec_init_reserved_memory(blob);
-		if (parent < 0)
+		if (parent < 0) {
+			log_debug("Failed: fdtdec_init_reserved_memory\n");
 			return parent;
+		}
 	}
 
 	/* only 1 or 2 #address-cells and #size-cells are supported */
@@ -1367,7 +1373,7 @@ int fdtdec_add_reserved_memory(void *blob, const char *basename,
 		addr = fdtdec_get_addr_size_fixed(blob, node, "reg", 0, na, ns,
 						  &size, false);
 		if (addr == FDT_ADDR_T_NONE) {
-			debug("failed to read address/size for %s\n", name);
+			log_debug("failed to read address/size for %s\n", name);
 			continue;
 		}
 
@@ -1391,7 +1397,7 @@ int fdtdec_add_reserved_memory(void *blob, const char *basename,
 			 lower);
 	else {
 		if (upper > 0) {
-			debug("address %08x:%08x exceeds addressable space\n",
+			log_debug("address %08x:%08x exceeds addressable space\n",
 			      upper, lower);
 			return -FDT_ERR_BADVALUE;
 		}
@@ -1400,17 +1406,23 @@ int fdtdec_add_reserved_memory(void *blob, const char *basename,
 	}
 
 	node = fdt_add_subnode(blob, parent, name);
-	if (node < 0)
+	if (node < 0) {
+		log_debug("Failed: fdt_add_subnode; error = %d\n", node);
 		return node;
+	}
 
 	if (phandlep) {
 		err = fdt_generate_phandle(blob, &phandle);
-		if (err < 0)
+		if (err < 0) {
+			log_debug("Failed: fdt_generate_phandle; error = %d\n", err);
 			return err;
+		}
 
 		err = fdtdec_set_phandle(blob, node, phandle);
-		if (err < 0)
+		if (err < 0) {
+			log_debug("Failed: fdtdec_set_phandle; error = %d\n", err);
 			return err;
+		}
 	}
 
 	/* store one or two address cells */
@@ -1430,13 +1442,17 @@ int fdtdec_add_reserved_memory(void *blob, const char *basename,
 	*ptr++ = cpu_to_fdt32(lower);
 
 	err = fdt_setprop(blob, node, "reg", cells, (na + ns) * sizeof(*cells));
-	if (err < 0)
+	if (err < 0) {
+		log_debug("Failed: fdt_setprop; error = %d\n", err);
 		return err;
+	}
 
 	if (no_map) {
 		err = fdt_setprop(blob, node, "no-map", NULL, 0);
-		if (err < 0)
+		if (err < 0) {
+			log_debug("Failed: fdt_setprop (no_map); error = %d\n", err);
 			return err;
+		}
 	}
 
 	/* return the phandle for the new node for the caller to use */
@@ -1460,17 +1476,17 @@ int fdtdec_get_carveout(const void *blob, const char *node, const char *name,
 
 	prop = fdt_getprop(blob, offset, name, &len);
 	if (!prop) {
-		debug("failed to get %s for %s\n", name, node);
+		log_debug("failed to get %s for %s\n", name, node);
 		return -FDT_ERR_NOTFOUND;
 	}
 
 	if ((len % sizeof(phandle)) != 0) {
-		debug("invalid phandle property\n");
+		log_debug("invalid phandle property\n");
 		return -FDT_ERR_BADPHANDLE;
 	}
 
 	if (len < (sizeof(phandle) * (index + 1))) {
-		debug("invalid phandle index\n");
+		log_debug("invalid phandle index\n");
 		return -FDT_ERR_BADPHANDLE;
 	}
 
@@ -1478,7 +1494,7 @@ int fdtdec_get_carveout(const void *blob, const char *node, const char *name,
 
 	offset = fdt_node_offset_by_phandle(blob, phandle);
 	if (offset < 0) {
-		debug("failed to find node for phandle %u\n", phandle);
+		log_debug("failed to find node for phandle %u\n", phandle);
 		return offset;
 	}
 
@@ -1486,7 +1502,7 @@ int fdtdec_get_carveout(const void *blob, const char *node, const char *name,
 							     "reg", 0, &size,
 							     true);
 	if (carveout->start == FDT_ADDR_T_NONE) {
-		debug("failed to read address/size from \"reg\" property\n");
+		log_debug("failed to read address/size from \"reg\" property\n");
 		return -FDT_ERR_NOTFOUND;
 	}
 
@@ -1506,13 +1522,13 @@ int fdtdec_set_carveout(void *blob, const char *node, const char *prop_name,
 
 	err = fdtdec_add_reserved_memory(blob, name, carveout, &phandle, false);
 	if (err < 0) {
-		debug("failed to add reserved memory: %d\n", err);
+		log_debug("failed to add reserved memory: %d\n", err);
 		return err;
 	}
 
 	offset = fdt_path_offset(blob, node);
 	if (offset < 0) {
-		debug("failed to find offset for node %s: %d\n", node, offset);
+		log_debug("failed to find offset for node %s: %d\n", node, offset);
 		return offset;
 	}
 
@@ -1530,7 +1546,7 @@ int fdtdec_set_carveout(void *blob, const char *node, const char *prop_name,
 					      (index + 1) * sizeof(value),
 					      &prop);
 		if (err < 0) {
-			debug("failed to resize reserved memory property: %s\n",
+			log_debug("failed to resize reserved memory property: %s\n",
 			      fdt_strerror(err));
 			return err;
 		}
@@ -1541,7 +1557,7 @@ int fdtdec_set_carveout(void *blob, const char *node, const char *prop_name,
 						  index * sizeof(value),
 						  &value, sizeof(value));
 	if (err < 0) {
-		debug("failed to update %s property for node %s: %s\n",
+		log_debug("failed to update %s property for node %s: %s\n",
 		      prop_name, node, fdt_strerror(err));
 		return err;
 	}
@@ -1609,6 +1625,8 @@ int fdtdec_setup(void)
 # endif
 #endif
 
+	log_debug("fdtdec_setup: gd->fdt_blob = %p\n", gd->fdt_blob);
+
 	ret = fdtdec_prepare_fdt();
 	if (!ret)
 		ret = fdtdec_board_setup(gd->fdt_blob);
@@ -1665,18 +1683,18 @@ int fdtdec_decode_ram_size(const void *blob, const char *area, int board_id,
 	int bank;
 	int len;
 
-	debug("%s: board_id=%d\n", __func__, board_id);
+	log_debug("%s: board_id=%d\n", __func__, board_id);
 	if (!area)
 		area = "/memory";
 	node = fdt_path_offset(blob, area);
 	if (node < 0) {
-		debug("No %s node found\n", area);
+		log_debug("No %s node found\n", area);
 		return -ENOENT;
 	}
 
 	cell = fdt_getprop(blob, node, "reg", &len);
 	if (!cell) {
-		debug("No reg property found\n");
+		log_debug("No reg property found\n");
 		return -ENOENT;
 	}
 
@@ -1695,11 +1713,11 @@ int fdtdec_decode_ram_size(const void *blob, const char *area, int board_id,
 		if (match_value >= 0 &&
 		    ((board_id & match_mask) == match_value)) {
 			/* Found matching mask */
-			debug("Found matching mask %d\n", match_mask);
+			log_debug("Found matching mask %d\n", match_mask);
 			node = child;
 			cell = fdt_getprop(blob, node, "reg", &len);
 			if (!cell) {
-				debug("No memory-banks property found\n");
+				log_debug("No memory-banks property found\n");
 				return -EINVAL;
 			}
 			break;
@@ -1716,7 +1734,7 @@ int fdtdec_decode_ram_size(const void *blob, const char *area, int board_id,
 
 	total_size = 0;
 	end = cell + len / 4 - addr_cells - size_cells;
-	debug("cell at %p, end %p\n", cell, end);
+	log_debug("cell at %p, end %p\n", cell, end);
 	for (bank = 0; bank < CONFIG_NR_DRAM_BANKS; bank++) {
 		if (cell > end)
 			break;
@@ -1737,12 +1755,12 @@ int fdtdec_decode_ram_size(const void *blob, const char *area, int board_id,
 		if (auto_size) {
 			u64 new_size;
 
-			debug("Auto-sizing %llx, size %llx: ", addr, size);
+			log_debug("Auto-sizing %llx, size %llx: ", addr, size);
 			new_size = get_ram_size((long *)(uintptr_t)addr, size);
 			if (new_size == size) {
-				debug("OK\n");
+				log_debug("OK\n");
 			} else {
-				debug("sized to %llx\n", new_size);
+				log_debug("sized to %llx\n", new_size);
 				size = new_size;
 			}
 		}
@@ -1752,7 +1770,7 @@ int fdtdec_decode_ram_size(const void *blob, const char *area, int board_id,
 		total_size += size;
 	}
 
-	debug("Memory size %llu\n", total_size);
+	log_debug("Memory size %llu\n", total_size);
 	if (sizep)
 		*sizep = (phys_size_t)total_size;
 
diff --git a/lib/time.c b/lib/time.c
index 38a9758292..8a4b41e3ad 100644
--- a/lib/time.c
+++ b/lib/time.c
@@ -92,8 +92,10 @@ uint64_t notrace get_ticks(void)
 		int ret;
 
 		ret = dm_timer_init();
-		if (ret)
+		if (ret) {
 			panic("Could not initialize timer (err %d)\n", ret);
+			while (1) {}
+		}
 #endif
 	}
 
diff --git a/lib/tiny-printf.c b/lib/tiny-printf.c
index 8fc7e48d99..29f897d78f 100644
--- a/lib/tiny-printf.c
+++ b/lib/tiny-printf.c
@@ -314,11 +314,13 @@ static int _vprintf(struct printf_info *info, const char *fmt, va_list va)
 			info->bf = p;
 			while (*info->bf++ && width > 0)
 				width--;
-			while (width-- > 0)
+			while (width-- > 0) {
 				info->putc(info, lz ? '0' : ' ');
+			}
 			if (p) {
-				while ((ch = *p++))
+				while ((ch = *p++)) {
 					info->putc(info, ch);
+				}
 			}
 		}
 	}
-- 
2.34.1

